// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`HoC @Consume and withConsumption selector observing. Should properly observe array selected props and prevent odd updates. 1`] = `
<Memo(DS.Observer)>
  <DS.Consumer
    onRender={
      [MockFunction] {
        "calls": Array [
          Array [
            Object {
              "first": "first",
              "third": false,
            },
          ],
        ],
        "results": Array [
          Object {
            "type": "return",
            "value": undefined,
          },
        ],
      }
    }
  >
    <RenderCallbacker
      first="first"
      onRender={
        [MockFunction] {
          "calls": Array [
            Array [
              Object {
                "first": "first",
                "third": false,
              },
            ],
          ],
          "results": Array [
            Object {
              "type": "return",
              "value": undefined,
            },
          ],
        }
      }
      third={false}
    >
      <div>
        {"first":"first","third":false}
      </div>
    </RenderCallbacker>
  </DS.Consumer>
</Memo(DS.Observer)>
`;

exports[`HoC @Consume and withConsumption selector observing. Should properly observe array selected props and prevent odd updates. 2`] = `
<Memo(DS.Observer)>
  <DS.Consumer
    onRender={
      [MockFunction] {
        "calls": Array [
          Array [
            Object {
              "first": "anotherValue",
              "third": false,
            },
          ],
        ],
        "results": Array [
          Object {
            "type": "return",
            "value": undefined,
          },
        ],
      }
    }
  >
    <RenderCallbacker
      first="anotherValue"
      onRender={
        [MockFunction] {
          "calls": Array [
            Array [
              Object {
                "first": "anotherValue",
                "third": false,
              },
            ],
          ],
          "results": Array [
            Object {
              "type": "return",
              "value": undefined,
            },
          ],
        }
      }
      third={false}
    >
      <div>
        {"first":"anotherValue","third":false}
      </div>
    </RenderCallbacker>
  </DS.Consumer>
</Memo(DS.Observer)>
`;

exports[`HoC @Consume and withConsumption selector observing. Should properly observe array selected props and prevent odd updates. 3`] = `
<Memo(DS.Observer)>
  <DS.Consumer
    onRender={[MockFunction]}
  >
    <RenderCallbacker
      first="anotherValue"
      onRender={[MockFunction]}
      third={false}
    >
      <div>
        {"first":"anotherValue","third":false}
      </div>
    </RenderCallbacker>
  </DS.Consumer>
</Memo(DS.Observer)>
`;

exports[`HoC @Consume and withConsumption selector observing. Should properly observe array selected props and prevent odd updates. 4`] = `
<Memo(DS.Observer)>
  <DS.Consumer
    onRender={[MockFunction]}
  >
    <RenderCallbacker
      first="anotherValue"
      onRender={[MockFunction]}
      third={false}
    >
      <div>
        {"first":"anotherValue","third":false}
      </div>
    </RenderCallbacker>
  </DS.Consumer>
</Memo(DS.Observer)>
`;

exports[`HoC @Consume and withConsumption selector observing. Should properly observe array selected props and prevent odd updates. 5`] = `
<Memo(DS.Observer)>
  <DS.Consumer
    onRender={
      [MockFunction] {
        "calls": Array [
          Array [
            Object {
              "first": "anotherValue",
              "third": true,
            },
          ],
        ],
        "results": Array [
          Object {
            "type": "return",
            "value": undefined,
          },
        ],
      }
    }
  >
    <RenderCallbacker
      first="anotherValue"
      onRender={
        [MockFunction] {
          "calls": Array [
            Array [
              Object {
                "first": "anotherValue",
                "third": true,
              },
            ],
          ],
          "results": Array [
            Object {
              "type": "return",
              "value": undefined,
            },
          ],
        }
      }
      third={true}
    >
      <div>
        {"first":"anotherValue","third":true}
      </div>
    </RenderCallbacker>
  </DS.Consumer>
</Memo(DS.Observer)>
`;

exports[`HoC @Consume and withConsumption selector observing. Should properly observe only one property and prevent odd updates. 1`] = `
<Memo(DS.Observer)>
  <DS.Consumer
    onRender={
      [MockFunction] {
        "calls": Array [
          Array [
            Object {
              "first": "first",
            },
          ],
        ],
        "results": Array [
          Object {
            "type": "return",
            "value": undefined,
          },
        ],
      }
    }
  >
    <RenderCallbacker
      first="first"
      onRender={
        [MockFunction] {
          "calls": Array [
            Array [
              Object {
                "first": "first",
              },
            ],
          ],
          "results": Array [
            Object {
              "type": "return",
              "value": undefined,
            },
          ],
        }
      }
    >
      <div>
        {"first":"first"}
      </div>
    </RenderCallbacker>
  </DS.Consumer>
</Memo(DS.Observer)>
`;

exports[`HoC @Consume and withConsumption selector observing. Should properly observe only one property and prevent odd updates. 2`] = `
<Memo(DS.Observer)>
  <DS.Consumer
    onRender={
      [MockFunction] {
        "calls": Array [
          Array [
            Object {
              "first": "anotherValue",
            },
          ],
        ],
        "results": Array [
          Object {
            "type": "return",
            "value": undefined,
          },
        ],
      }
    }
  >
    <RenderCallbacker
      first="anotherValue"
      onRender={
        [MockFunction] {
          "calls": Array [
            Array [
              Object {
                "first": "anotherValue",
              },
            ],
          ],
          "results": Array [
            Object {
              "type": "return",
              "value": undefined,
            },
          ],
        }
      }
    >
      <div>
        {"first":"anotherValue"}
      </div>
    </RenderCallbacker>
  </DS.Consumer>
</Memo(DS.Observer)>
`;

exports[`HoC @Consume and withConsumption selector observing. Should properly observe only one property and prevent odd updates. 3`] = `
<Memo(DS.Observer)>
  <DS.Consumer
    onRender={[MockFunction]}
  >
    <RenderCallbacker
      first="anotherValue"
      onRender={[MockFunction]}
    >
      <div>
        {"first":"anotherValue"}
      </div>
    </RenderCallbacker>
  </DS.Consumer>
</Memo(DS.Observer)>
`;

exports[`HoC @Consume and withConsumption selector observing. Should properly observe only one property and prevent odd updates. 4`] = `
<Memo(DS.Observer)>
  <DS.Consumer
    onRender={[MockFunction]}
  >
    <RenderCallbacker
      first="anotherValue"
      onRender={[MockFunction]}
    >
      <div>
        {"first":"anotherValue"}
      </div>
    </RenderCallbacker>
  </DS.Consumer>
</Memo(DS.Observer)>
`;

exports[`HoC @Consume and withConsumption selector observing. Should properly observe selector picked props and prevent odd updates. 1`] = `
<Memo(DS.Observer)>
  <DS.Consumer
    onRender={
      [MockFunction] {
        "calls": Array [
          Array [
            Object {
              "prop": 2,
            },
          ],
        ],
        "results": Array [
          Object {
            "type": "return",
            "value": undefined,
          },
        ],
      }
    }
  >
    <RenderCallbacker
      onRender={
        [MockFunction] {
          "calls": Array [
            Array [
              Object {
                "prop": 2,
              },
            ],
          ],
          "results": Array [
            Object {
              "type": "return",
              "value": undefined,
            },
          ],
        }
      }
      prop={2}
    >
      <div>
        {"prop":2}
      </div>
    </RenderCallbacker>
  </DS.Consumer>
</Memo(DS.Observer)>
`;

exports[`HoC @Consume and withConsumption selector observing. Should properly observe selector picked props and prevent odd updates. 2`] = `
<Memo(DS.Observer)>
  <DS.Consumer
    onRender={[MockFunction]}
  >
    <RenderCallbacker
      onRender={[MockFunction]}
      prop={2}
    >
      <div>
        {"prop":2}
      </div>
    </RenderCallbacker>
  </DS.Consumer>
</Memo(DS.Observer)>
`;

exports[`HoC @Consume and withConsumption selector observing. Should properly observe selector picked props and prevent odd updates. 3`] = `
<Memo(DS.Observer)>
  <DS.Consumer
    onRender={
      [MockFunction] {
        "calls": Array [
          Array [
            Object {
              "prop": 56656,
            },
          ],
        ],
        "results": Array [
          Object {
            "type": "return",
            "value": undefined,
          },
        ],
      }
    }
  >
    <RenderCallbacker
      onRender={
        [MockFunction] {
          "calls": Array [
            Array [
              Object {
                "prop": 56656,
              },
            ],
          ],
          "results": Array [
            Object {
              "type": "return",
              "value": undefined,
            },
          ],
        }
      }
      prop={56656}
    >
      <div>
        {"prop":56656}
      </div>
    </RenderCallbacker>
  </DS.Consumer>
</Memo(DS.Observer)>
`;
